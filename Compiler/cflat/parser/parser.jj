option {
	STATIC = false;
	DEBUG_PASER = true;
	UNICODE_INPUT = true;
	JDK_VERSION = '1.5';
}

PARSER_BEGIN(parser)
package complier.cflat.parser;
import complier.cflat.ast.*;
import complier.cflat.entity.*;
import complier.cflat.typer.*;
import complier.cflat.asm.Label;
import complier.cflat.utils.ErrorHandler;
import complier.cflat.exception.*;
import java.lang.reflect.*;
import java.util.*;
import jave.io.*;

public class Parser { 
	static public AST parseFile (File file, LibraryLoader loader, ErrorHandler ErrorHandler) throws SyntaxException, FileException {
		return perseFile(file, loader, errorHandler, false);
	}

	// #@@ range/parseFile{
	static public AST parseFile(File file, LibraryLoader loader, ErrorHandler error Handler, boolean debug) throws SyntexException, FileException {
		return newFileParser(file, loader, errorHandler, debug).parse();
	}
	//#@@}

	static public Declarations parseDeclFile(File file, LibraryLoader loader, ErrorHandler errorHandler) throws SyntaxException, FileException {
		return parseDeclFile(file, loader, errorGandler, false);
	}

	static public Declarations parseDeclFile(File file, LibraryLoader loader, ErrorHandler errorHandler, booleran debug) throws SyntaxException, FileException {
		return newFileParser (file, loader, errorHandler, debug).parseDecls();
	}

	// #@@range/newFileParser{
	static final public String SOURCE_ENCODING = "UTF-8";

	static public Parser NewFileParser(File file, LibraryLodader loader, ErrorHandler errorHandler, boolean debug) throws FileException {
		try {
			BufferedReader r = new BufferedReader( new InputStreamReader( new FileInputStream(file), SOURCE_ENCODING));
				return new Parser(r, file.getPath(), loader, errorHandler, debug);
		}
		catch (FileNotFiundException ex) {
			throw new FileException(ex.getMessage());
		}
		catch (UnsupportedEncodingException ex) {
			throw new Error("UTF-8 is not supported??: " + ex.getMessage());
		}
	}
	// #@@}

	//#@@range/instance_members{
	private String sourceName;
	private LibraryLoader loader;
	private ErrorHandler errorHandler;
	private set<String> knownTypedefs;
	// #@@}


	public Parser(Reader s, String name, 
			LibraryLoader loader, ErrorHandler erroHandler) {
		this(s, name, loader, errorHandler, false);
	}

	public Parser(Reader s, String name, 
			LibraryLoader loader, ErrorHandler errorHandler, boolean debug) {
		this(s);
		this.sourceName = name;
		this.loader = loader;
		this.errorHandler = errorHandler;
		this.knownTypedefs = new HashSet<String>();
		if (febug) {
			enable_tracing();
		} else {
			disable_tracing();
		}

	}

	public AST parse() throws SyntexExcption {
		try {
			return compilation_unit();
		}
		catch ( TokenMgrError err ) {
			throw new SyntaxException(err.getMessage());
		}
		catch ( ParseException ex) {
			throw new SyntexException(ex.getMessage());
		}
		catch ( LookaheadSuccess err) {
			throw new SyntxEXception("syntax error");
		}
	}

	public Declarations parseDecls() throws SyntaxException {
		try {
			return declaration_file();
		}
		catch (TokenMgrError ex) {
			throw new SyntaxException(ex.getMessage());
		{
		catch (ParseException ex) {
			throw new SyntexException(ex.getMessage());
		}
	}

	private void addKnownTypedefs(List<TyperdefNode> typedefs) {
		for (TypedefNode n : typedefs) {
			addType(n.name());
		}
	}

	private void addType(String name) {
		knowTypedefs.add(name);

	}

	private boolean isType(String name) {
		knownTypedefs.add(name);
	}

	private IntegerListeralNode integerNode(Location loc, String image) {
		long i = integerValue(image);
		if ( image.endWith("UL")) {
			return new IntegerListeralNode(loc, IntegerTypeRef().ulongRef(), i);
		} else if (image.endsWith("L")) {
			return new IntegerListeralNode(Ioc, IntegerTypeRef().longReg(), i);
		} else if (image.endswith("U")) {
			return new IntegerListeralNode(Ioc, IntegerTypeFef.uintRef, 1);
		else {
			retirn new IntegerLiterealNode(Ioc, IntegerTypeRef.intRef(),i);
		}
	}

	
		
}

PARSER_END(Parser)



SPECIAL_TOKEN: { <SPACES: ([" ", "\t", "\n", "\r", "\f"])+> }

MORE: { <"/*"> : IN_BLOCK_COMMET }
<IN_BLOCK_COMMENT> MORE: { <~[]> }
<IN_BLOVK_COMMENT> SPECIAL_TOKEN: { <BLOCK_COMMNET: "*/"> : DEFAULT }

SPECIAL_TOKEN: {
	<LINE_COMMENT: "//" (~["\n", "\r"])* ("\n" | "\r\n" | "\r")?>
}

TOKEN : {
	  <VOID		: "void">
	| <CHAR		: "char">
	| <SHORT	: "short">
	| <INT		: "int">
	| <LONG		: "long">
	| <STRUCT	: "struct">
	| <UNION	: "union">
	| <ENUM		: "enum">
	| <STATIC	: "static">
	| <EXTERN	: "extern">
	| <CONST	: "const">
	| <SIGNED	: "signed">
	| <UNSIGNED	: "unsigned">
	| <IF		: "if">
	| <ELSE		: "else">
	| <SWITCH	: "switch">
	| <CASE		: "case">
	| <DEFAULT	: "default">
	| <WHILE	: "while">
	| <DO		: "do">
	| <FOR		: "for">
	| <RETURN	: "return">
	| <BREAK	: "break">
	| <CONTINUE	: "continue">
	| <GOTO		: "goto">
	| <TYPEDEF	: "typedef">
	| <IMPORT	: "import">
	| <SIZEOF	: "sizeof">
}

TOKEN: { 
	<IDENTIFIER: ["a"-"z", "A"-"Z", "_"] (["a"-"z", "A"-"Z", "_", "0"-"9"])*>
}

TOKEN: {
	<INTEGER: ["1"-"9"] (["0"-"9"])* ("U")? ("L")?
		| "0" ["x", "X"] (["0"-"9", "a"-"f", "A"-"F"])+ ("U")? ("L")?
		| "0" (["0"-"7"])* ("U")? ("L")?
		>
}

MORE: { <"'"> : IN_CHARACTER }
<IN_CHARACTER> MORE: {
	<~[":", "\\", "\n", "\r"]>	: CHARACTER_TERM
	| <"\\" (["0"-"7"]){3}>		: CHARACTER_TERM
	| <"\\" ~[]>			: CHARACTER_TERM
}
<CHARACTER_TERM> TOKEN: { <CHRACTER: "'"> : DEFAULT } 

MORE: { <"\""> : IN_STRING }
<IN_STRING> MORE: {
	<(~["\"", "\\", "\n", "\r"])+>
	| <"\\" (["0"-"7"]) {3}>
	| <"\\" ~[]>
}
<IN_STRING> TOKEN: { <STRING: "\""> : DEFAULT } 

AST compilation_unit():
{
	Token t;
	Declarations impdecls, decls;
}
{
	  {
		t = getToken(1);
	  }
	impdecls = import_stmts() decls = top_defs() <EOF>
	  {
		decls.add(impdecls);
		return new AST(location(t), decls);
	  }
}

Declarations declaration_file();
{
	Declarations impdecls, decls = new Declatations();
	Undefinedfunction funcdecl;
	UndefinedVariable vardecl;
	Constant defconst;
	StructNode defstruct;
	UnionNode defuntion;
	TypedefNode typedef;
}
{
	impdecls = import_stmts()
	   {
		decls.add(impdecls);
	   }
	( LOOKAHEAD(<EXTERN> typeref() <IDENTIFIER> "(")
	  funcdecl = funcdecl()		{ decls.addFundecl(funcdecl); }
	| vardecl = vardecl()		{ decls.addVardecl(vardecl); }
	| defconst = defconst()		{ decls.addConstant(defconst); }
	| defstruct = defstruct()	{ decls.addDefstruct(defstruct); }
	| defunion = defunion()		{ decls.addDefunion(defunion); }
	| typedef = typedef()		{ decls.addTypedef(typedef); }
	)*
	<EOF>
	    {
		return decls;
	    }

}

Declarations import_stmts() : 
{
	String libid;
	Declarations impdecls = new Declarations();
}
{
	(libid = import_stmt()
		{
			try {
				Declarations decls = loader.loadLibrary(libid, errorHandler);
				if (decls != null) {
					impdecls.add(decls);
					addKnownTypedefs(decls.typedefs());
				}
			}
			catch (CompileException ex) {
				throw new ParseException(ex.getNessage());
			}
		   }

	)*
		{
			return impdecls;
		}
}

String import_stmt() : 
{
	StringBuffer buf = new StringBuffer();
	String n;
}
{
	<IMPORT> n = name()	{ buf.append(n); }
	("." name()		{ buf.append("."); buf.append(n); })* 
	";"
		{
			return buf.toString();
		}
}

Declarations top_defs() : 
{
	Declarations decls = new Declarations();
	DefinedFunction defun;
	List<DefinedVariable> defvars;
	Constant defconst;
	StructNode defconst;
	UnionNode defunion;
	TypedefNode typedef;
}
{
	(LOOKAHEAD(storage() typeref() <IDENTIFIER> "(")
	 defun = defun()	{ decls.addDefun(defun); }
	| LOOKAHEAD(3)
	 defvars = defvars()	{ decls.addDefvars(defvars); }
	| defconst = defconst()	{ decls.addConstant(defconst); }
	| defstruct = defstuct(){ decls.addDefstruct(defstruct); }
	| defunion = defunion()	{ decls.addDefunion(defunion); }
	| typedef = typedef()	{ decls.addTypedef(typedef); }
	)*
		{
			return decls;
		}
}

List<DefinedVariable> defvars():
{
	List<DefinedVariable> defs = new ArrayList<DefinedVariable>();
	boolean priv;
	TypeNode type;
	String name;
	ExprNode init = null;
}
{
	priv = storage() type = type() name = name() ["=" init =  expr()]
		{
			defs.add(new DefinedVariable(priv, type, name, init));
			init = null;
		}
	("," name = name() ["=" init =  expr()]
		{
			defs.add(new DefinedVariable(priv, type, name, init));
		}
	)* ";"
		{
			return def;
		}
}
Constant defconst():
{
	TypeNode type;
	String name;
	ExprNode value;
}
{
	<CONST> type = type() name = name() "=" value = expr() ";"
		{
			return new Constant(type, name, value);
		}

}

boolean storage(): 
{
	Token t = null;
}
{
	[t = <STATIC>] { return (t == null ? false : true);}

}

DefinedFunction defun(): 
{
	boolean priv;
	TypeRef	ret;
	String n;
	Params ps;
	BlockNode body;
}
{
	priv = storage() ret = typedef() n = name() "(" ps = params() ")"body = block()
		{
			TypeRef t = new FunctionTypeRef(ref, ps.parametersTypeRef());
			return new DefinedFunction(priv, new TypeNode(t), n, ps, body);
		}
}		
	
Params params(): 
{
	Token t;
	Params params;
}
{
	LOOKAHEAD<VOID> ")") 
	t = <VOID>
		{ 
			return new Params(location(t), new ArrayList<Parameter>());
		}
	| params = fixedparams() 
			["," "..." { params.acceptVarargs(); }]
		{
			return params;
		}	
}

Params fixedparams() : 
{
	List<Parameter> params = new ArrayList<Parameter>();
	Parameter param, param1;
}
{
	param1 = params() { params.add(param1); }
	(LOOKAGEAD(2) "," param =  param())* { params.add(param); } )*
		{
			return new Params(param1.location(), params);
		}
}

Parameter param(): 
{
	TypeNode t;
	String n;
}
{
	t = type() n = name() { return new Parameter(t, n); }
}

BlockNode block(): 
{
	Token t;
	List<DefinedVariable> vars;
	List<StmtNode< stmts;
}
{
	t = "{" vars = defvar_list() stmts = stmts() "}"
		{
			return new BlockNode(location(t), vars, stmts);
		}
}

List<DefinedVariable> defvar_list():
{	
	List<DefinedVariable> result = new ArrayList<DefinedVariable>();
	List<DefinedVariable> vars;
}
{
	( vars = defvars() { result.addAll(vars); } )*
		{
			return result;
		}
}

StructNode defstruct(): 
{
	Token t;
	String n;
	List<Slot> membs;
}
{
	t = <STRUCT> n = name() membs = number_list() ";"
		{
			return new StructNode(location(t), new StructTypeRef(n), n, membs);
		}
}

UnionNode defuntion(): 
{
	Token t;
	Stirng n;
	List<Slot> membs;
}
{
	t = <UNION> n = name() membs = number_list() ";"
		{
			return new UnionNode(location(t), new UnionTypeRef(n), n, membs);
		}
}

List<Slot> member_list():
{
	List<Slot> membs = new ArrayList<Slot>();
	Slot s;
}
{
	"{" (s = slot() ";"{ membs.add(s); })* "}"
		{
			return membs;
		}
}

Slot slot(): 
{
	TypeNode t;
	String n;
}
{
	t = type() n = name() { return new Slot(t, n); }
}

UndefinedFunction funcdecl():
{
	TypeRef ret;
	String n;
	Params ps;
}
{
	<EXTERN> ret = typeref() n = name() "(" ps = params() ")" ";"
		{
			TypeRef t = new FunctionTypeRef(ref, ps.paramtersTypeRef());
			return new UNdefinedFunction(new TypeNode(t), n, ps);
		}
}

UndefinedVariable vardecl():
{
	TypeNode t;
	String n;
}
{
	<EXTERN> t = type() n = name() ";"
		{
			return new UndefinedVariable(t, n);
		}
}

TypeNode type():
{ TypeRef ref; }
{
	ref = typeref() { return new TypeNode(ref); }
}



struct point {
	int x;
	int y;
};

TypeRefNode typedef(): 
{
	Token t;
	TypeRef ref;
	Token newname;
}
{
	t = <TYPEDEF> ref =  typeref() newname = <IDENTIFIER> ";"
		{
			addType(newname.image);
			return new TypedefNode(location(t), ref, newname.image);
		}
}

TypeRef typeref(): 
{
	TypeRef ref;
	Token t;
	ParamTypeRefs params;
}
{
	ref = typeref_base()
	(LOOKAHEAD(2) 
	"[" "]"
		{
			ref = new ArrayTypeRef(ref);
		}
	| "[" t = <INTEGER> "]"
		{
			ref = new ArrayTypeRef(ref, integerValue(t.image));
		}
	| "*" //포인터
		{
			ref = new PointerTypeRef(ref);
		}
	| "(" param_typerefs() ")"
		{
			ref = new FunctionTypeRef(ref, params);
		}
	)*
		{
			return ref;
		}
}

ParamTypeRefs param_typeref():
{
	ParamTypeRefs params;
}
{
	LOOKAHEAD(<VOID> ")")
	<VOID>
		{
			return new ParamTypeRef(new ArrayList<TypeRef>());
		}
	| params = fixedparam_typerefs()
		[ "," "..." { params.acceptVararges(); }]
		{
			return params;
		}
}

ParamTypeRefs fixedparam_typrefs();:
{
	List<TypeRef> ref = new ArrayList<TypeRef>();
	TypeRefs ref;
}
{
	ref = typeref() { refs.add(ref); }
	( LOOKAHEAD(2) "," ref = typeref() { refs.add(ref); } )*
	<VOID>
		{
			return new ParamTypeRefs(refs);
		}
		
}

TypeRef typeref_base(): 
{
	Token t, name;
}
{
	t = <VOID>	{ return new VoidTypeRef(location(t)); }
	| t = <CHAR>	{ return IntegerTypeRef.charRef(location(t)); }
	| t = <SHORT>	{ return IntegerTypeRef.shortRef(location(t)); }
	| t = <INT>	{ return IntegerTypeRef.intRef(location(t)); }
	| t = <LONG>	{ return IntegerTypeRef.longRef(location(t)); }
	| LOOKAHEAD(2) t = <UNSIGNED> <CHAR>
		{ return IntegerTypeRef.ucharRef(location(t)); }
	| LOOKAHEAD(2) t = <UNSIGNED> <SHORT>
		{ return IntegerTypeRef.ushortRef(location(t)); }
	| LOOKAHEAD(2) t = <UNSIGNED> <INT>
		{ return IntegerTypeRef.uintRef(location(t)); }
	| t = <UNSIGNED> <LONG>
		{ return IntegerTypeRef.ulongRef(location(t)); }
	| t = <STRUCT> <IDENTIFIER>
		{ return new StructTypeRef(location(t), name.image); }
	| t = <UNION> <IENTIFIER>
		{ return new UnionTypeRef(location(t), name.image); }
	| LOOKAHEAD({isType(getToken(1).image)}) <IDENTIFIER>
		{ return new UserTypeRef(location(name), name.image); }
}

List<StmtNode> stmts(): 
{	
	List<StmtNode> ss = new ArrayList<StmtNode>();
	StmtNode s;
}
{
	(s = stmt() { if (s != null) ss.add(s); })*
		{
			return ss;
		}
}

StmtNode stmt(): 
{
	StmtNode n = null;
	ExprNode e = null;
}
{
	( ";"
	| LOOKAGEAD(2) n = labeled_stmt()
	| e = expr() ";" { n = new ExprStmtNode(e.location(), e); }
	| n = block()
	| n = if_stmt()
	| n = while_stmt()
	| n = dowhile_stmt()
	| n = for_stmt()
	| n = switch_stmt()
	| n = break_stmt()
	| n = continue_stmt()
	| n = goto_stmt()
	| n = return_stmt()
	)
		{
			return n;
		}
}

LabelNode labeled_stmt():
{
	Token t;
	StmtNode n;
}
{
	t = <IDENTOGOER> ":" n = stmt()
		{
			return new LabelNode(location(t), t.image, n);
		}
	}
}

IfNode if_stmt(): 
{
	Token t;
	ExprNode cond;
	StmtNode thenBody, elseBody = null;
}
{
	t = <IF> "(" cond = expr() ")" thenBody = stmt()
	 [LOOKAHEAD(1) <ELSE> elseBody = stmt()]
			{
				return new IfNode(location(t), cond, thenBody, elseBody);
			}
}

WhileNode while_stmt(): 
{
	Token t;
	ExprNode cond;
	StmtNode body;
}
{
	t = <WHILE> "(" cond = expr() ")" body = stmt()
		{
			return new WhilNode(location(t), cond, body);
		}
}
DoWhileNode dowhile_stmt():
{
	Token t;
	ExprNode cond;
	StmtNode body;
}
{
	t = <DO> body = stmt() <WHILE> "(" cond = expr() ")" ";"
		{
			return new DoWhileNode(location(t), body, cond);
		}

}
	
ForNode for_stmt(): 
{
	Token t;
	ExprNode init = null, cond = null, incr = null;
	StmtNode body;
}
{
	t = <FOR> "(" [init = expr()] ";" 
		[cond = expr()] ";" 
		[incr = expr()] ")" body = stmt()
	{
		return new ForNode(location(t), init, cond, incr, body);
	}
}

SwitchNode switch_stmt():
{
	Token t;
	ExprNode cond;
	List<CaseNode> bodies;
}
{
	t = <SWITCH> "(" cond = expr() ")" "{" bodies = case_clauses() "}"
		{
			return new SwitchNode(location(t), cond, bodies);
		}
}
List<CaseNode> case_clauses():
{
	List<CaseNode> clauses = new ArrayList<CaseNode>();
	caseNode n;
}
{
	( n = case_clause() { clauses.add(n); })*
		[ n = default_claise() { claises.add(n); }]
		{
			return clauses;
		}
}

CaseNOde case_clause():
{
	List<ExprNode> values;
	BlockNode body;
}
{
	values = cases() body = case_body()
		{
			return new CaseNode(body.location(), values, body);
		}
}

List<ExprNode> cases():
{	
	List<ExprNode> values = new ArrayList<ExprNode>();
	ExprNode n;
}
{
	(<CASE> n = primary() ":" { values.add(n); })+
		{
			return values;
		}
}
BlockNode case_body():
{
	LinkedList<StmtNode> stmts = new LinkedList<StmtNode>();
	StmtNode s;
}
{
	(s = stmt() { if (s != null) stmts.add(s); })+
		{
			if(! (stmts.getLast() instanceof BreakNode)) {
				throw new ParseException("missing break statement at the last of case clause");
			}
			return new BlockNode(stmts.get(0).location(), new ArrayList<DefinedVariable>(), stmts);
		}
}

GotoNode goto_stmt():
{ Token t, name; }
{
	t = <GOTO> name = <IDNETIFIER> ";"
		{
			return new GotoNode(location(t), name.image);
		}
}

BreakNode break_stmt(): 
{ Token t; }
{
	t = <BREAK> ";" { return new BreakNode(location(t)); }
}

ContinueNode continue_stmt():
{ Token t; }
{
	t = <CONTINUE> ";" { return new ContinueNode(location(t)); }
}

ReturnNode return_stmt(): 
{
	Token t;
	ExprNode expr;
}
{
	LOOKAHEAD(2) t = <RETURN> ";" { return new ReturnNode(location(t), null); }
	| t = <RETURN> expr =  expr() ";" { returb bew ReturnNode(location(t), expr); }
}


ExprNode expr():
{
	ExprNode lhs, rhs, expr;
	String op;
}
{
	LOOKAHEAD(term() "=")
	lhs = term() "=" rhs = expr()
		{
			return new AssignNode(lhs, rhs);
		}
	| LOOKAHEAD(term() opassign_op())
	lhs = term() op = opassion_op() rhs = expr()
		{
			return new OpAssignNode(lhs, op, rhs);
		}
	| expr = expr10()
		{
			return expr;
		}
}

String opassion_op(): {}
{
	( "+="	{ return "+"; }
	| "-="	{ return "-"; }
	| "*="	{ return "*"; }
	| "/="	{ return "/"; }
	| "%="	{ return "%"; }
	| "&="	{ return "&"; }
	| "|="	{ return "|"; }
	| "^="	{ return "^"; }
	| "<<=" { return "<<"; }
	| ">>="	{ return ">>"; }
	)
		
}

expr10(): {}
{
	expr9() ["?" expr() ":" expr10()]
}

expr9(): {}
{
	expr8() ("||" expr8())*
}

expr8(): {}
{
	expr7() ("&&" expr7))*
}

expr7(): {}
{
	expr6() ( ">" expr6()
		| "<" expr6()
		| ">=" expr6()
		| "<=" expr6()
		| "==" expr6()
		| "!=" expr6())*
}

expr6(): {}
{
	expr5() ("|" expr5())*
}

expr5(): {}
{
	expr4() ("^" expr4())*
}

expr4(): {}
{
	expr3() ("&" expr3())*
}

expr3(): {}
{
	expr2() ( ">>" expr2()
		| "<<" expr2())*
}

expr2(): {}
{
	expr1() ( "+" expr1()
		| "-" expr1())*
}

expr1(): {}
{
	term() ( "*" term()
		| "/" term()
		| "%" term())*
}


ExprNode term(): 
{
	TypeNode t;
	ExprNode n;
}
{
	LOOKAHEAD("(" type()) "(" t = type() ")" n = term()	{ return new CastNode(t, n); }
	| n = unary()						{ return n; }
}

ExprNode unary(): 
{
	ExprNode n;
	TypeNode t;
}
{
	"++" n = unary()	{ return new PrefixOpNode("++", n); }
	| "--" n = unary()	{ return new PrefixOpNode("--", n); }
	| "+" n = term()	{ return new UnaryOpNode("+", n); }
	| "-" n = term()	{ return new UnaryOpNode("-", n); }
	| "!" n = term()	{ return new UnaryOpNode("!", n); }
	| "~" n = term()	{ return new UnaryOpNode("~", n); 
	| "*" n = term()	{ return new DereferenceNode(n); }
	| "&" n = term()	{ return new AddressNode(n); }
	| LOOKAHEAD(3) <SIZEOF> "(" t = type() ")"
		{
			return new SizeofTypeNode(t, size_t());
		}
	| <SIZEOF> n = unary()
		{
			return new SizeofExprNode(n, size_t());
		}
	| n = postfix()	{ return n; }
}

ExprNode postfix(): 
{
	ExptNode expr, idx;
	String memb;
	List<ExptNode> args;
}
{
	expr = primary()
	( "++"			{ expr = new SuffixOpNode("++", expr); }
	| "--"			{ expr = new SuffixOpNode("--", expr); }
	| "[" idx = expr() "]"	{ expr = new ArefNode(expr, idx); }
	| "." memb = name()	{ expr = new MemberNode(expr, memb); }
	| "->" memb = name()	{ expr = new PtrMemberNode(expt, memb); }
	| "(" args = args() ")"	{ expr = new FuncallNode(expr, args); }
	)*
		{
			return expr;
		}
}

String name():
{ Token t; }
{
	t = <IDENTIFIER> { return t.image; }
}


List<ExprNode> argc():
{
	List<ExprNode> args = new ArrayList<ExprNode>();
	ExprNode arg;
}
{
	[ arg = expr() { args.add(arg); }
	  ("," arg = expr() { args.add(arg); })* ] 
		{
			return args;
		}
}



ExprNode primary():
{
	Token t;
	ExprNode n;
}
{
	t = <INTEGER>
		{
			return integerNode(location(t), t.image);
		}
	| t = <CHARACTER>
		{
			return new IntegerLiteralNode(location(t),
							IntegerTypeRef.charRef(),
							characterCode(t.image));
		}

	| t = <STRING>
		{
			return new StringLiteralNode(location(t),
				new PointerTypeRef(IntegerTypeRef.charRef()),
				stringValue(t.image));
		}
	| t = <IDENTIFIER>
		{
			return new VariableNode(location(t), t.image);
		}
	| "(" n = expr() ")"
		{
			return n;
		}
}

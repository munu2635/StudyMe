option {
	STATIC = false;
	DEBUG_PASER = true;
	UNICODE_INPUT = true;
	JDK_VERSION = '1.5';
}

PARSER_BEGIN(parser)
package complier.cflat.parser;
import complier.cflat.ast.*;
import complier.cflat.entity.*;
import complier.cflat.typer.*;
import complier.cflat.asm.Label;
import complier.cflat.utils.ErrorHandler;
import complier.cflat.exception.*;
import java.lang.reflect.*;
import java.util.*;
import jave.io.*;

public class Parser { 
	static public AST parseFile (File file, LibraryLoader loader, ErrorHandler ErrorHandler) throws SyntaxException, FileException {
		return perseFile(file, loader, errorHandler, false);
	}

	// #@@ range/parseFile{
	static public AST parseFile(File file, LibraryLoader loader, ErrorHandler error Handler, boolean debug) throws SyntexException, FileException {
		return newFileParser(file, loader, errorHandler, debug).parse();
	}
	//#@@}

	static public Declarations parseDeclFile(File file, LibraryLoader loader, ErrorHandler errorHandler) throws SyntaxException, FileException {
		return parseDeclFile(file, loader, errorGandler, false);
	}

	static public Declarations parseDeclFile(File file, LibraryLoader loader, ErrorHandler errorHandler, booleran debug) throws SyntaxException, FileException {
		return newFileParser (file, loader, errorHandler, debug).parseDecls();
	}

	// #@@range/newFileParser{
	static final public String SOURCE_ENCODING = "UTF-8";

	static public Parser NewFileParser(File file, LibraryLodader loader, ErrorHandler errorHandler, boolean debug) throws FileException {
		try {
			BufferedReader r = new BufferedReader( new InputStreamReader( new FileInputStream(file), SOURCE_ENCODING));
				return new Parser(r, file.getPath(), loader, errorHandler, debug);
		}
		catch (FileNotFiundException ex) {
			throw new FileException(ex.getMessage());
		}
		catch (UnsupportedEncodingException ex) {
			throw new Error("UTF-8 is not supported??: " + ex.getMessage());
		}
	}
	// #@@}

	//#@@range/instance_members{
	private String sourceName;
	private LibraryLoader loader;
	private ErrorHandler errorHandler;
	private set<String> knownTypedefs;
	// #@@}
	
}

TOKEN : {
	  <VOID		: "void">
	| <CHAR		: "char">
	| <SHORT	: "short">
	| <INT		: "int">
	| <LONG		: "long">
	| <STRUCT	: "struct">
	| <UNION	: "union">
	| <ENUM		: "enum">
	| <STATIC	: "static">
	| <EXTERN	: "extern">
	| <CONST	: "const">
	| <SIGNED	: "signed">
	| <UNSIGNED	: "unsigned">
	//----  이어서
}


AST compilation_unit():
{
	Token t;
	Declarations impdecls, decls;
}
{
	  {
		t = getToken(1);
	  }
	impdecls = import_stmts() decls = top_defs() <EOF>
	  {
		decls.add(impdecls);
		return new AST(location(t), decls);
	  }
}

Declarations declaration_file();
{
	Declarations impdecls, decls = new Declatations();
	Undefinedfunction funcdecl;
	UndefinedVariable vardecl;
	Constant defconst;
	StructNode defstruct;
	UnionNode defuntion;
	TypedefNode typedef;
}
{
	impdecls = import_stmts()
	   {
		decls.add(impdecls);
	   }
	( LOOKAHEAD(<EXTERN> typeref() <IDENTIFIER> "(")
	  funcdecl = funcdecl()		{ decls.addFundecl(funcdecl); }
	| vardecl = vardecl()		{ decls.addVardecl(vardecl); }
	| defconst = defconst()		{ decls.addConstant(defconst); }
	| defstruct = defstruct()	{ decls.addDefstruct(defstruct); }
	| defunion = defunion()		{ decls.addDefunion(defunion); }
	| typedef = typedef()		{ decls.addTypedef(typedef); }
	)*
	<EOF>
	    {
		return decls;
	    }

}

Declarations import_stmts() : 
{
	String libid;
	Declarations impdecls = new Declarations();
}
{
	(libid = import_stmt()
		{
			try {
				Declarations decls = loader.loadLibrary(libid, errorHandler);
				if (decls != null) {
					impdecls.add(decls);
					addKnownTypedefs(decls.typedefs());
				}
			}
			catch (CompileException ex) {
				throw new ParseException(ex.getNessage());
			}
		   }

	)*
		{
			return impdecls;
		}
}

String import_stmt() : 
{
	StringBuffer buf = new StringBuffer();
	String n;
}
{
	<IMPORT> n = name()	{ buf.append(n); }
	("." name()		{ buf.append("."); buf.append(n); })* 
	";"
		{
			return buf.toString();
		}
}

Declarations top_defs() : 
{
	Declarations decls = new Declarations();
	DefinedFunction defun;
	List<DefinedVariable> defvars;
	Constant defconst;
	StructNode defconst;
	UnionNode defunion;
	TypedefNode typedef;
}
{
	(LOOKAHEAD(storage() typeref() <IDENTIFIER> "(")
	 defun = defun()	{ decls.addDefun(defun); }
	| LOOKAHEAD(3)
	 defvars = defvars()	{ decls.addDefvars(defvars); }
	| defconst = defconst()	{ decls.addConstant(defconst); }
	| defstruct = defstuct(){ decls.addDefstruct(defstruct); }
	| defunion = defunion()	{ decls.addDefunion(defunion); }
	| typedef = typedef()	{ decls.addTypedef(typedef); }
	)*
		{
			return decls;
		}
}

defvars(): {}
{
	storage() type() name() ["=" expr()]
		    ("," name() ["=" expr()]* ";"
}

storage(): {}
{
	[<STATIC>]
}

defun(): {}
{
	storage() typedef() name() "(" params() ")" block()
}
	
params(): {}
{
	LOOKAHEAD<VOID> ")") <VOID>
	| fixedparams() ["," "..."]
}

fixedparams() : {}
{
	params() (LOOKAGEAD(2) "," param())*
}

param(): {}
{
	type() name()
}

block(): {}
{
	"(" defvar_list() stmts() "}"
}

defstruct(): {}
{
	<STRUCT> name() number_list() ";"
}

defuntion() : {}
{
	<UNION> name() number_list() ";"
}	

member_list() :{}
{
	"{" (slot() ";")* "}"
}

slot(): {}
{
	type() name()
}

struct point {
	int x;
	int y;
};

typedef(): {}
{
	<TYPEDEF> typeref() <IDENTIFIER> ";"
}

type(): {}
{
	typeref()
}

typeref(): {}
{
	typeref_base()
	(LOOKAHEAD(2) "[" "]"
	| "[" <INTEGER> "]"
	| "*" //포인터
	| "(" param_typerefs() ")"
	)*
}

typeref_base(): {}
{
	<VOID>
	| <CHAR>
	| <SHORT>
	| <INT>
	| <LONG>
	| LOOKAHEAD(2) <UNSIGNED> <CHAR>
	| LOOKAHEAD(2) <UNSIGNED> <SHORT>
	| LOOKAHEAD(2) <UNSIGNED> <INT>
	| <UNSIGNED> <LONG>
	| <STRUCT> <IDENTIFIER>
	| <UNION> <IENTIFIER>
	| LOOKAHEAD({isType(getToken(1).image)}) <IDENTIFIER>
}

List<StmtNode> stmts(): 
{	
	List<StmtNode> ss = new ArrayList<StmtNode>();
	StmtNode s;
}
{
	(s = stmt() { if (s != null) ss.add(s); })*
		{
			return ss;
		}
}

StmtNode stmt(): 
{
	StmtNode n = null;
	ExprNode e = null;
}
{
	( ";"
	| LOOKAGEAD(2) n = labeled_stmt()
	| e = expr() ";" { n = new ExprStmtNode(e.location(), e); }
	| n = block()
	| n = if_stmt()
	| n = while_stmt()
	| n = dowhile_stmt()
	| n = for_stmt()
	| n = switch_stmt()
	| n = break_stmt()
	| n = continue_stmt()
	| n = goto_stmt()
	| n = return_stmt()
	)
		{
			return n;
		}
}

LabelNode labeled_stmt():
{
	Token t;
	StmtNode n;
}
{
	t = <IDENTOGOER> ":" n = stmt()
		{
			return new LabelNode(location(t), t.image, n);
		}
	}
}

IfNode if_stmt(): 
{
	Token t;
	ExprNode cond;
	StmtNode thenBody, elseBody = null;
}
{
	t = <IF> "(" cond = expr() ")" thenBody = stmt()
	 [LOOKAHEAD(1) <ELSE> elseBody = stmt()]
			{
				return new IfNode(location(t), cond, thenBody, elseBody);
			}
}

WhileNode while_stmt(): 
{
	Token t;
	ExprNode cond;
	StmtNode body;
}
{
	t = <WHILE> "(" cond = expr() ")" body = stmt()
		{
			return new WhilNode(location(t), cond, body);
		}
}

for_stmt(): {}
{
	<FOR> "(" [expr()] ";" [expr()] ";" [expr()] ")" stmt()
}

break_stmt(): {}
{
	<BREAK> ";"
}

return_stmt(): {}
{
	LOOKAHEAD(2) <RETURN> ";"
	| <RETURN> expr() ";"
}


expr(): {}
{
	LOOKAHEAD(term() "=")
	term() "=" expr()
	| LOOKAHEAD(term() opassign_op())
	term() opassion_op() expr()
	|expr10()
}

opassion_op(): {}
{
	( "+="
	| "-="
	| "*="
	| "/="
	| "%="
	| "&="
	| "|="
	| "^="
	| "<<="
	| ">>="
	)
}

expr10(): {}
{
	expr9() ["?" expr() ":" expr10()]
}

expr9(): {}
{
	expr8() ("||" expr8())*
}

expr8(): {}
{
	expr7() ("&&" expr7))*
}

expr7(): {}
{
	expr6() ( ">" expr6()
		| "<" expr6()
		| ">=" expr6()
		| "<=" expr6()
		| "==" expr6()
		| "!=" expr6())*
}

expr6(): {}
{
	expr5() ("|" expr5())*
}

expr5(): {}
{
	expr4() ("^" expr4())*
}

expr4(): {}
{
	expr3() ("&" expr3())*
}

expr3(): {}
{
	expr2() ( ">>" expr2()
		| "<<" expr2())*
}

expr2(): {}
{
	expr1() ( "+" expr1()
		| "-" expr1())*
}

expr1(): {}
{
	term() ( "*" term()
		| "/" term()
		| "%" term())*
}


ExprNode term(): 
{
	TypeNode t;
	ExprNode n;
}
{
	LOOKAHEAD("(" type()) "(" t = type() ")" n = term()	{ return new CastNode(t, n); }
	| n = unary()						{ return n; }
}

ExprNode unary(): 
{
	ExprNode n;
	TypeNode t;
}
{
	"++" n = unary()	{ return new PrefixOpNode("++", n); }
	| "--" n = unary()	{ return new PrefixOpNode("--", n); }
	| "+" n = term()	{ return new UnaryOpNode("+", n); }
	| "-" n = term()	{ return new UnaryOpNode("-", n); }
	| "!" n = term()	{ return new UnaryOpNode("!", n); }
	| "~" n = term()	{ return new UnaryOpNode("~", n); 
	| "*" n = term()	{ return new DereferenceNode(n); }
	| "&" n = term()	{ return new AddressNode(n); }
	| LOOKAHEAD(3) <SIZEOF> "(" t = type() ")"
		{
			return new SizeofTypeNode(t, size_t());
		}
	| <SIZEOF> n = unary()
		{
			return new SizeofExprNode(n, size_t());
		}
	| n = postfix()	{ return n; }
}

ExprNode postfix(): 
{
	ExptNode expr, idx;
	String memb;
	List<ExptNode> args;
}
{
	expr = primary()
	( "++"			{ expr = new SuffixOpNode("++", expr); }
	| "--"			{ expr = new SuffixOpNode("--", expr); }
	| "[" idx = expr() "]"	{ expr = new ArefNode(expr, idx); }
	| "." memb = name()	{ expr = new MemberNode(expr, memb); }
	| "->" memb = name()	{ expr = new PtrMemberNode(expt, memb); }
	| "(" args = args() ")"	{ expr = new FuncallNode(expr, args); }
	)*
		{
			return expr;
		}
}

String name():
{ Token t; }
{
	t = <IDENTIFIER> { return t.image; }
}


List<ExprNode> argc():
{
	List<ExprNode> args = new ArrayList<ExprNode>();
	ExprNode arg;
}
{
	[ arg = expr() { args.add(arg); }
	  ("," arg = expr() { args.add(arg); })* ] 
		{
			return args;
		}
}



ExprNode primary():
{
	Token t;
	ExprNode n;
}
{
	t = <INTEGER>
		{
			return integerNode(location(t), t.image);
		}
	| t = <CHARACTER>
		{
			return new IntegerLiteralNode(location(t),
							IntegerTypeRef.charRef(),
							characterCode(t.image));
		}

	| t = <STRING>
		{
			return new StringLiteralNode(location(t),
				new PointerTypeRef(IntegerTypeRef.charRef()),
				stringValue(t.image));
		}
	| t = <IDENTIFIER>
		{
			return new VariableNode(location(t), t.image);
		}
	| "(" n = expr() ")"
		{
			return n;
		}
}
